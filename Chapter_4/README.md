## 练习4.1

> 表达式`5 + 10 * 20 / 2`的求值结果是多少？

105

## 练习4.2

> 根据4.12节中的表，在下面表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。

```cpp
(a) *vec.begin()       //*(vec.begin())
(b) *vec.begin() + 1   // (*(vec.begin())) + 1
```

## 练习4.3

> C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

可以接受，因为C++的优势就是执行效率，有时我们需要编译器的特性来进行有效的工作。

**Note**

优先级只是规定了运算对象的组合方式，但并没有说明运算对象的求值顺序，比如`int i = f1() * f2();`, 我们不知道f1和f2的调用顺序。由于`<<`运算符没有明确规定何时以及如何对运算对象求值，故下列输出表达式是未定义的，故无法推断其行为；

```cpp
int i = 0;
cout << i << " " << ++i << endl; // 未定义地
```

**算数运算符**

* 布尔值不应该参与算术运算，因为非算数类型在运算时会转换为能进行算数类型的类型， `bool b = true; bool b2 = -b;`b2的值为true， 因为b参与运算时会提升为整数值1，取负值后为-1，再将-1转换为布尔值作为b2的初始值，显然不等于0，转换为布尔值应该为1，故b2为true。


* 若m%n不为0，则值的符号与m相同

## 练习4.4

> 在下面的表达式中添加括号，说明其求值的过程以及最终结果。编写程序编译该（不加括号的）表达式并输出其结果验证之前的推断。

```cpp
12 / 3 * 4 + 5 * 15 + 24 % 4 / 2  // ((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2)
```

结果为91

## 练习4.5

> 写出下列表达式的求值结果

```cpp
(a) -30 * 3 + 21 / 5;  // -86
(b) -30 + 3 * 21 / 5;  // -18
(c) 30 / 3 * 21 % 5;  // 0
(d) -30 / 3 * 21 % 4; // -2
```

## 练习4.5

> 写出一条表达式用于确定一个整数是奇数还是偶数。

```cpp
num % 2 == 0 ? "even" : "odd";
```

## 练习4.7

> 溢出是何含义？写出三条将导致溢出的表达式。

```cpp
(a) 10 / 0;
(b) short a = 32768;
(c) unsigned ua = -1;
```

算数表达式可能会产生未定义的结果。一部分原因是数学性质本身，比如除数为0；另外一部分则源于计算机的特点：例如溢出，当计算的结果超出该类型所能表示的范围时就会产生溢出。

## 练习4.8

> 说明在逻辑与、逻辑或及相等性运算符中运算对象求值的顺序。

逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略成为短路求值

* 对于逻辑与运算符来说，当且仅当左侧运算对象为**真**时才对右侧对象求值
* 对于逻辑或运算符来说，当且仅当左侧运算对象为**假**时才对右侧对象求值

## 练习4.9

> 解释在下面的if语句中条件部分的判断过程。

```cpp
const char *cp = "Hello World";
if (cp && *cp)
```

`cp`为`const char *`指针，并且不为空指针，true

`*cp`为`const char` ： `H`，并且为非0数据，true

`true && true => true`

## 练习4.10

> 为while循环写一个条件，使其从标准输入中读取整数，遇到42时停止。

```cpp
int num = 0;
while(std::cin >> num && num != 42)
```

## 练习4.11

> 书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。

```cpp
a > b && b > c && c > d
```

## 练习4.12

> 假设i、j和k是三个整数，说明表达式`i != j < k`的含义。

该表达式等同于`i != (j < k)`

首先计算`j < k`，得到的布尔值作为` != `运算符的右侧运算对象。即将`i`与`j、k`的比较结果真假值进行吧比较。可以将表达式重写为

`i != j && j < k`

**Note**

> 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象

